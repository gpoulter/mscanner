"""Configuration for MedScanner

Configuration options are stored in the "rc" variable in this module, which is a
utils.RCStorage object.

@note: The reason for things like pseudocount being here is that they only
change between invocations. Within the program, pseudocount is really a
constant and it would be a pain to make sure that the same value gets passed
down through the call graph. Everyone who uses pseudocount et al knows that in
configuration.rc.pseudocount lies the Single Point of Truth regarding its
value.

@note: For parameters which depend on others, prefix with lambda:
so that the dependency is updated dynamically.

                                   
"""

__license__ = """
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

http://www.gnu.org/copyleft/gpl.html
"""

from path import path
from mscanner.storage import RCStorage

rc = RCStorage()

#### PATH CONFIGURATION

## Path to MScanner source directory
rc.sources = path(__file__).dirname().parent
## Path to directory for report templates
rc.templates = lambda: rc.sources / "mscanner" / "templates"
## Path to working information directory
rc.working = lambda: rc.sources.parent / "data"
## Path to cache directory
rc.cache = lambda: rc.working / "cache"
## Path to web directory
rc.htdocs = lambda: rc.sources / "htdocs"
## DB environment directory
rc.db_env_home = lambda: rc.cache / "db_home"
## DB of article objects
rc.articledb = lambda: rc.cache / "articles.db"
## Path for list of of article IDs
rc.articlelist = lambda: rc.cache / "articles.txt"
## Path for number of articles
rc.narticles = lambda: rc.cache / "narticles.txt"
## Path for DB of term features for each article
rc.featuredb = lambda: rc.cache / "features.db"
## Path for binary stream of PMIDs and feature arrays
rc.featurestream = lambda: rc.cache / "features.stream"
## Path for feature<->ID mapping
rc.featuremap = lambda: rc.cache / "featuremap.txt"
## Path for list of files already processed
rc.processed = lambda: rc.cache / "processed.txt"
## Path for directory with compressed Medline
rc.medline = lambda: rc.working / "medline"
## Path for log file
rc.logfile = lambda: rc.cache / "lastlog.txt"
## Path for status file
rc.statusfile = lambda: rc.cache / "mscanner.pid"
## Path for e-mail alert file
rc.emails_path = lambda: rc.cache / "emails.txt"
## Path for stylesheet for reports
rc.stylesheet = lambda: rc.templates / "style.css"
## Path to corpora directory
rc.corpora = lambda: rc.working / "corpora"
## Path to outputs directory
rc.query_report_dir = lambda: rc.working / "query" / rc.dataset
## Path to outputs directory
rc.valid_report_dir = lambda: rc.working / "validation" / rc.dataset

### PharmDemo-specific Configuration

## Path for GAPScore results db
rc.gapscore = lambda: rc.working / "genedrug" / "gapscore.db"
## Path for gene-drug co-occurrence cache
rc.genedrug = lambda: rc.working / "genedrug" / "genedrug.db"
## Path for pickled drug table (generated by drugtable.py)
rc.drugtable = lambda: rc.working / "genedrug" / "drugtable.txt"
## PharmDemo database output (file path or connection string)
rc.pharmdemo_db = None
## If True, output to PharmDemo instead of standard report
rc.pharmdemo = False

### Report File Names

## Name of result score file
rc.report_result_scores = path("result_scores.txt")
## Name of file with citation records for the input
rc.report_input_citations = path("input_citations.html")
## Name of file with citation records for the output
rc.report_result_citations = path("result_citations.html")
## Path of file with positive input PMIDs (and their scores)
rc.report_positives = path("positives.txt")
## Name of file with negative input PMIDs (and their scores)
rc.report_negatives = path("negatives.txt")
## Path to index file
rc.report_index = path("index.html")
## Name of term score file
rc.report_term_scores = path("term_scores.csv")
## Name of histogram file
rc.report_artscores_img = path("artscores.png")
## Name of feature score density file
rc.report_featscores_img = path("featscores.png")
## Name of ROC curve file
rc.report_roc_img = path("roc.png")
## Name of PR curve file
rc.report_prcurve_img = path("prcurve.png")
## Name of PRF vs threshold file
rc.report_fmeasure_img = path("fmeasure.png")

#### Global parameters

## Whether to use transactions while updating
rc.use_transactions = False
## Number of seconds to pause before next file while updating
rc.save_delay = 2
## Per-term pseudocount to use
rc.pseudocount = 0.01
## Whether to purge negative-only features having positive scores 
rc.cutoff = False
## Types of features to exclude
rc.exclude_types = []
## Server for sending e-mails
rc.smtpserver = "smtp.uct.ac.za" # "smtp.stanford.edu"
## Whether to use Daniel's 10^-8 pseudocounts
rc.dodaniel = False

#### Web-configurable parameters

## Name of dataset
rc.dataset = "default"
## Float for minimum score threshold
rc.threshold = 0
## Integer for maximum number of results (may be fewer due to threshold)
rc.limit = 1000
## Number of validation folds to use
rc.nfolds = 10
## 0<Alpha<1.  Alpha=0.5 maximises standard F-Measure.
rc.alpha = 0.5
## Number of negatives to use
rc.numnegs = 500000
## Whether to do a gene-drug co-occurrence filter
rc.dogenedrug = False
## Number of citations per output file
rc.citations_per_file = 250

## Logging configuration
def initLogger(console=True, logfile=None):
    """Configure logging for MScanner. By default log to file, 
    and console.
    
    @param console: Whether to log to console or not
    @param logfile: File for logging (default to rc.logfile)
    """
    logfile = logfile if logfile else rc.logfile
    import logging
    rootlog = logging.getLogger()
    rootlog.setLevel(0)
    format = logging.Formatter("%(asctime)-9s %(levelname)-8s %(message)s", "%H:%M:%S")
    filelog = logging.FileHandler(logfile, "w")
    filelog.setFormatter(format)
    rootlog.addHandler(filelog)
    if console:
        console = logging.StreamHandler()
        console.setFormatter(format)
        rootlog.addHandler(console)
